# 1、什么是js?js是单线程还是多线程?

	简单的来说js就是运行在浏览器中的解释性语言,脚本语言,是单线程
	

# 2、数据类型有哪些?怎么判断数据类型?

    基本数据类型:
        数字类型:number
        布尔类型:boolean
        字符串类型:string
    复合引用数据类型:
        数组:Array
        对象:object
        函数:function
    特殊数据类型:
        null
        undefined
        NaN
    检测数据类型的方法
        typeof:检测基本数据类型
        Array.isArray():检测数组类型
        isNaN:检测不是一个数字
        
# 3、在js中=、==、===区别？
	=赋值：给某个变量进行赋值
	==等于：只比较大小，不会比较数据类型
	===全等于：不光比较大小还会比较数据类型
# 4、i++和++i的区别？
	i++:先取i的值，作为表达式i++的结果，然后在对i进行+1【先赋值后加1】
	++i：先取i的值进行+1,然后取i的值作为++i的表达式的结果【先加1后赋值】
# 5、while和do while有啥区别？
	while必须是条件成立才能执行循环体。
	do while就算条件不成立也能执行一次循环。先执行一次循环然后再去判断条件是否成立。
	如果成立接着循环，不成立结束循环
# 6、break和continue区别？
	break:终止循环，看到break后面的代码就不执行了
	continue:跳出当前循环，开始执行下一次循环

# 7、小九九必须会默写

# 8、知不知道递归函数？递归函数会经常用吗？递归函数的缺点是什么？
    递归函数：函数中自己调用自己的函数就是递归函数
    公司明文规定禁止使用递归函数，因为递归函数必须等待最后一次运行的结果的出现才能完成逻辑执行，违背了内存管理机制.垃圾回收机制，所以不让使用

# 9、用过闭包函数吗？什么是闭包函数，闭包函数的优缺点？内存泄漏，js回收机制？
	闭包就是能够读取函数内部的变量的函数，定义在函数内部的函数
	闭包的优点：可以在全局重复使用变量并且不会造成变量的污染
	缺点：闭包容易造成内存泄露。比较消耗内存，内存消耗过多，会导致浏览器很卡。

	内存泄漏：指一块被分配的内存既不能使用，又不能回收，直到浏览器进程结束。
	JS的回收机制：JavaScript垃圾回收的机制很简单：找出不再使用的变量，然后释放掉其占用的内存
	js中最常用的垃圾回收方式就是标记清除。比如在函数中声明一个变量，就将这个变量标记为“进入环境”。从逻辑上讲，永远不能释放进入环境的变量所占用的内存，因为只要执行流进入相应的环境，就可能会用到它们。而当变量离开环境时，则将其标记为“离开环境”。
# 如何避免闭包引起的内存泄露？ 哪些操作会造成内存泄露？
	如何避免闭包引起的内存泄露？
		注意程序逻辑 避免死循环
		减少不必要的全局变量，在函数最后将不使用的变量赋值为空
		避免创建过多的对象

	哪些操作会造成内存泄露？
		①意外的全局变量
		②脱离DOM的元素引用
		③未清除的定时器
		④闭包函数
		⑤console.log

# 10、什么是命名函数？匿名函数？递归函数?回调函数？函数表达式？
	命名函数：有名字的函数
	匿名函数：没有名字的函数
	*递归函数：函数中自己调用自己的函数就是递归函数
	*回调函数：被作为参数传递的函数是回调函数，并且可以访问另一个函数内部的变量
	函数表达式：带有变量的函数，用变量调用的函数
	*构造函数：
	*闭包函数：

# 11、for与forEach区别？
	forEach不能够使用break,forEach没有返回值。return 返回的是undefined

# 12、什么是全局，局部变量？
	全局变量：在函数体外部声明的变量就是全局变量，省略var声明的变量也称作全局变量。全局变量在函数体内部和外部都可以使用。
	局部变量：在函数体里面定义的变量叫做局部变量，只能在函数体内部使用，函数体外部不能使用

# 13、什么是预解析？
	在预解析中，变量的提升，只会在当前作用域中提升，提升到当前作用域最上方。
	函数的变量只会提前到函数作用域的最前方

# 14、请说一下数组常用的方法有哪些?
	push():添加到数组的最后
	splice():删除指定的元素,并且在删除的位置添加元素
	Sting()、toString():将数组转为字符串
	join():拼接字符串,将数组用什么符号转为字符串
	split():将字符串转为数组
	shift():删除数组的第一项
	pop():删除数组的最后一项
	unshift():将内容添加到数组的开头

	sort():正序排序从小到大
	concat():合并数组
	reverse():反转

# 15、请说获取dom方法有几种？
	*document.getElementById("id选择器")：获取单个元素
	document.getElementsByTagName("标签名")：获取的是一组数据，伪数组。注意：s
	document.getElementsByName("name名称")：获取的是一组数据，伪数组。注意：s
	document.getElementsByClassName("类名选择器")：获取的是一组数据，伪数组。注意：s
	*document.querySelector("选择器"):通过选择器获取单个节点
	*document.querySelectorAll("选择器"):通过选择器获取多个节点。伪数组，可以通过下标取值
	parentNode：父节点
	children：子节点
	兄弟节点、事件委托等等

# 16、面试题：dom操作的方法？
	appendChild：添加节点到最后
	insertBefore：在某个位置插入
	removeChild：删除子节点
	replaceChild：修改子节点
	cloneNode：复制克隆节点

# 17、获取设置类名的方法？
	*className:获取或者设置类名，其中设置类名会覆盖原来的类名。所以设置类名的时候要把之前的类名也加上
	.classList.add(""):添加类名
	.classList.remove(""):移除类名
	setAttribute()

# 18 innerHTML和innerText的区别?
	相同点:都可以获取或者设置内容
	innerHTML:以代码的形式设置/获取内容
	innerText:以文本的形式设置/获取内容
	
# 19 js获取或者设置属性的方法
	①通过dom进行获取或者设置属性.dom.属性
	②通过getAttribute()获取自定义属性
	通过setAttribute()设置自定义属性

# 20 怎样提升浏览器的加载速度?
	文件的外部引入
	减少冗余代码,将代码进行封装
	使用事件委托代替dom获取,减少dom操作
	图片的懒加载
	压缩文件

# 21 什么是事件冒泡?怎样阻止事件冒泡:
	两个div两两嵌套,都添加点击事件,我点击里面的div的时候,外面的div事件也会出触发
	阻止事件冒泡方法:e.stopPropagation()

	jq阻止事件冒泡方法:return false
	
# 22、事件绑定，解绑的方法
	addEventListener
	removeEventListener
	
# 23、什么是window对象？什么是document对象？
	window对象就是BOM，也就是浏览器对象：window对象封装了窗口标题，工具栏按钮，地址栏，状态栏等等都是window的成员对象。(window就是BOM也就是浏览器)
	
	document对象就是dom，代表的是html整个的文档，可以用来访问网页中所有的元素，dom属于window对象的一部分。（document就是dom,也就是网页）
# 24、for in和for of有什么区别？for of为什么遍历对象会报错
	for in遍历数组得到的是索引下标，遍历对象得到的是属性，不能遍历map对象
	for of遍历数组得到的是值，遍历对象会报错。因为没有引入iterable，需要加上Object.keys(),Object.values()才能使用，遍历map对象得到的是属性和值
# 25、说一下你对this的理解：
	
	在浏览器中，在全局范围内this指向的是window
	在函数中，this指向的是调用者拥有者
	在构造函数中，this指向的是new出来的那个新对象
	call,apply，bind中的this被强绑定在那个对象中
		
	在箭头函数中this属于当前所处的最大的对象，而不是执行时的对象
	箭头函数没有自己的this, 它的this是继承而来; 默认指向在定义它时所处的对象(宿主对象),此处指父级作用域,而不是执行时的对象,

# 26、用过深拷贝，浅拷贝吗？深拷贝浅拷贝的区别？如何实现深拷贝浅拷贝？JSON深拷贝的弊端及解决方案
	深拷贝:就是b复制了a,当修改a的时候，b不会随着a的变化而变化，拥有独立的内存。
	将数据中所有的数据拷贝下来，对拷贝之后的数据进行修改不会影响到原数据。

	浅拷贝就是b复制了a,当修改a时，b中的子元素不会随着a的变化而变化，但是b中的子对象中的元素会随着a的改变而改变。原数据和复制后的数据的第一层不会改变，第二层或者深层会改变

	浅拷贝方法：slice，concat，es6剩余运算符
	深拷贝：
		JSON.parse()、JSON.stringify()
		jq的extend方法
		通过递归去拷贝所有的层级

	JSON弊端:
		1、如果obj里面存在时间对象,通过JSON方法会导致时间对象变成了字符串。
		2、如果obj里有RegExp、Error对象，转化后的结果是空对象。
		3、如果obj里有函数，undefined，则序列化的结果会把函数，undefined丢失。
		4、如果obj里有NaN、Infinity和-Infinity，则序列化的结果会变成null。
		5、JSON.stringify()只能序列化对象的可枚举的自有属性。如果obj中的对象是有构造函数生成的， 则使用JSON.parse(JSON.stringify(obj))深拷贝后，会丢弃对象的constructor。
		6、如果对象中存在循环引用的情况也无法正确实现深拷贝。
	解决:递归实现深拷贝

# 27、什么是面向对象，面向对象的特点？
	面向对象就是一种编程思想，是由属性和方法组成
	面向对象的特点：封装，继承，多态
	
# 28、什么是构造函数？构造函数偷偷帮我们干了那两件事情？
	用new关键字调用的函数称为构造函数

	1 帮我们偷偷创建了一个空白对象
	2 替我们将结果返回出去
# 29、面向对象的继承方式？
	call或者apply方法
	原型链prototype
	利用空对象作为中介

# 30、什么是异步什么是同步：

	同步，可以理解为在执行完一个函数或方法之后，一直等待系统返回值或消息，只有接收到返回的值或消息后才往下执行其他的命令。  具有等待功能

	异步，执行完函数或方法后，不必等待返回值或消息，就可以直接执行下一个命令。不用等待

# 31 知道promise对象吗？promise有几种状态？什么情况下进入catch，封装过接口吗？
	promise对象，处理异步函数的，就是将异步改成同步执行。
		pending(未待定状态)
		fulfilled(成功状态)
		rejected(失败的状态)
		
		当状态是失败的时候,会进入catch

# 32、http定义？http的三次握手？
	http是一种网络传输协议，浏览器作为http客户端通过url向http服务器发起请求，服务器接收的请求向客户端发送响应信息

	1 客户端向服务端发送请求
	2 服务端接收到请求需要进行核对操作，发送的请求服务端能不能接收到，如果接收到，就向客户端返回接收到的请求信息
	3 客户端拿着服务器返回成功接收到的这个信息再去向服务器发送请求，两者才能建立联系

# 33、请求的方式有哪些？post和get的区别？
	delete put post get等等等
	1 安全性问题：
		get请求参数会被拼接到地址栏上，信息会暴漏
		post请求参数不可见
	2 数据传输量：
		get有长度限制的
		post没有
	3 缓存问题
		get数据会被缓存
		post是不会

# 34、常见的状态码:
	*200 请求成功
	301 资源被永久转移到其他url
	*400 客户端请求语法错误
	401 发送请求需要被认证
	*403 请求的资源被服务器拒绝
	*404 表面服务器无法找到指定的资源
	*500 表示服务端在执行请求的时候发生了错误
	*502 服务器网关出现了错误
	503 服务器处于停机维护 现在无法处理请求	

# 35、创建ajax的步骤
	1 创建XMLHttpRequest对象，也就是创建一个异步调用对象
	2 创建一个http请求，并指定请求方法 （建立连接）
	3 发送http	请求
	4 获取返回的数据
# 36、mouseover与mouseenter的区别？
	mouseover:鼠标指向的时候触发,当鼠标指向被选元素及其后代元素时触发，会产生事件冒泡
	mouseenter:鼠标指向的时候触发,当鼠标指向被选元素时触发，不会产生事件冒泡

# 37、什么是防抖？什么是节流？
	防抖就是多次执行变为最后一次执行，实现函数的防抖：延时器
	节流就是多次执行变成每隔一段时间执行。实现函数节流的方法：定时器和时间戳

# 38、sessionStorage，localStorage，cookie区别：
	共同点：都是保存数据
	① sessionStorage生命周期是当前窗口或者标签页，一旦窗口或者标签页关闭，所有的存储的数据也会被清空
	② localStorage生命周期是永久的。除非用户手动清除信息，否则这些信息永久存在
	③ cookie是浏览器与服务器之间来回传递，cookie浏览器关闭数据一直保存，只在过期时间内有效，可以设置过期时间。cookie存储数据不能超过4k,sessionStorage，localStorage存储的数据可以是5M，甚至更多。

# 39、var let const的区别？
	1 var声明的变量属于全局变量，属于window,var声明的变量可以声明多次，可以修改，并且var声明的变量存在变量的提升
	2 let只在块级作用域中使用即{}，不存在变量提升，let只能声明一次不能重复定义，let声明的变量存在暂时性死区。
	3 conts声明的是一个只读常量，声明之后不允许改变，而且必须初始化，const定义的基本数据是不可以改变的，但是定义的对象或者是数组可以通过下标或者属性来修改

为什么const可以修改对象或者数组？
	const指针指向的地址是不可以改变的，但是地址的内容是可以改变的
# 40、es6中如何实现数组去重？
	用new Set(数组)实现去重
# 怎样将伪数组转为数组？
	Array.from或者剩余运算符去将类数组转成数组
	然后用数组的方法去实现逻辑
	
# 41、es6的新特性
	新的声明方式
	结构性赋值，剩余运算符
	数组的遍历方式for of，find等方法
	箭头函数
	symbol，set去重，map方法，字符串模板，promise，模块化
	class和extends,super调用父类的方法

# 42 谈谈async/await 的使用方式和场景
	async 是用来修饰函数的声明, 使用async修饰的函数会变成一个异步函数.可以使用then来接收参数
	await 用来修饰函数的调用, 被 await 修饰的函数返回一个promise 异步对象, 使用 await 修饰后, 就会将 promise 异步对象转换成一个同步操作。其中直接提取resolve里面的值
# 43.箭头函数有什么作用及实际应用场景?
	箭头函数的作用：
		①箭头函数的语法比函数表达式更简洁。
		②箭头函数可以解决this指向问题。箭头函数不会创建自己的this，它只会从自己的作用域链向上一层继承this。
	箭头函数的使用场景：
		①简单的函数表达式，内部没有thi引用，没有递归，事件绑定，解绑定。
		②需要调用this，且this指向和上一层作用域链保持一致时。如保证指向vue实例对象。

# 44.class 类的如何实现继承,简单实现?
	子类继承父类——语法：class 子类 extends 父类，在子类的构造方法中使用super调用父类的构造方法。
# 45 什么是跨域？解决跨域？
	跨域指的是：浏览器不能执行其他网站的脚本，从一个域名的网页去请求另一个域名的资源时，域名、端口、协议任一不同，都是跨域。跨域是由浏览器的同源策略造成的，是浏览器施加的安全限制

	解决：①设置跨域代理、在vue中的config.js中proxy设置
	②jsonp
	③后端处理
	④借调
# 46 事件循环机制
	js是单线程语言，一次只能完成一个任务，如果同时完成多个任务怎么办？js把任务分为同步和异步任务，把所有的同步放到主线程上去执行，把所有的异步任务放到事件队列里去，当所有的同步任务都执行完之后，去事件队列中看看有没有没有执行的异步任务，如果有把需要先执行的异步任务拉到主线程上去执行，当这个任务执行完后，再去事件队列里看有没有没完成的任务，如果有再把任务拉到主线程去执行，这样就形成一个事件循环。
# 47 宏任务和微任务?
	浏览器的事件循环（event loop）中分成宏任务和微任务。JS 中任务分成同步任务和异步任务。
宏任务
	JS 中主栈执行的大多数的任务，例如：定时器，事件绑定，ajax，回调函数，node中fs操作模块等就是宏任务
微任务
	promise, async/await, process.nextTick等就是微任务。
# 48 图片的懒加载
  懒加载也就是延迟加载。有时候一个网页会包含很多的图片，例如淘宝京东这些购物网站，商品图片多只之又多，页面图片多，加载的图片就多。服务器压力就会很大。不仅影响渲染速度还会浪费带宽。比如一个1M大小的图片，并发情况下，达到1000并发，即同时有1000个人访问，就会产生1个G的带宽。

# 49 懒加载原理
  一张图片就是一个<img>标签，浏览器是否发起请求图片是根据<img>的src属性，所以实现懒加载的关键就是，在图片没有进入可视区域时，先不给<img>的src赋值，这样浏览器就不会发送请求了，等到图片进入可视区域再给src赋值。

# 50 懒加载思路及实现
  实现懒加载有四个步骤，如下：
  1.加载loading图片
  2.判断哪些图片要加载【重点】
  3.隐形加载图片
  4.替换真图片

# 100、常用方法
	转数字：
		Number()
	转字符串：
		toString()
		String()
	保留两位小数：
		toFixed()
	数组转字符串方法:
		Sting()、toString()、join()
	字符串转数组:
		split()
	字符截取：
		substring()
		substr()
	字符串修改：
		replace()
	json字符串转json对象：
		JSON.parse()
	json对象转json字符串：
		JSON.stringify()

	检测字符串开头：startWith
	检测字符串结尾：endWith

	字符串前面填充：padStart() 
	字符串后面填充：padEnd() 